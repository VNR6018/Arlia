module CLI

    open AST
    open DAST
    open Parser
    open FParsec
    open Desugger
    open IndentParser
    open Typechecker
    open Printter

    open Exceptions

    [<Literal>]
    let version = "0.03"

    let by =
        let creators = [ "vanaur" ] in
        System.String.Join(", ", creators)

    let private welcome (inwhat: string) = sprintf """     ___       ______    __       __       ___      
    /   \     |   _  \  |  |     |  |     /   \         
   /  ^  \    |  |_)  | |  |     |  |    /  ^  \        Version %s
  /  /_\  \   |      /  |  |     |  |   /  /_\  \       By %s
 /  _____  \  |  |\  \  |  `---. |  |  /  _____  \      Type :? for help in the CLI
/__/     \__\ |__| \__\ |______| |__| /__/     \__\     Read in %s
____________________________________________________    
 """ 
                                            version by inwhat

    let private helpText = """
 >> Help <<
 > Visit 'https://vanaur.github.io/Home.html' for language assistance

    === CLI

    | ':?'    | ':h'    | ':help'              -> show this help
    | ':load' | ':run' ----------- <file>      -> starts a new instance of the CLI by loading the file 
    | ':q'    | ':quit'                        -> exit
    | ':cls'  | ':clear'                       -> clear the console

    === Language

    | ':t'    | ':type' ---------- <expr|fun>  -> get the type of the expression / function
    | ':cenv'                                  -> clear the actual REPL environment
    | ':ast' --------------------- <expr>      -> displays the desugarized AST generated by the given expression
    | ---------------------------- <code>      -> executes the Arlia code and update the current code environment

    === Debug

    | ':i'    | ':infos' --------- <err>       -> gives additional information about an error (<err> ::= number)
 """

(*
    | ':?'    | ':h'    | ':help'              -> show this help
    | ':t'    | ':type' ---------- <expr|fun>  -> get the type of the expression / function
    | ':load' | ':run' ----------- <file>      -> starts a new instance of the CLI by loading the file 
    | ':q'    | ':quit'                        -> exit
    | ':cenv'                                  -> clear the actual REPL environment
    | ':cls'  | ':clear'                       -> clear the console
    | ':ast' --------------------- <expr>      -> displays the desugarized AST generated by the given expression
    | ':i'    | ':infos' --------- <err>       -> gives additional information about an error (<err> ::= number)
    | ---------------------------- <code>      -> executes the Arlia code and update the current code environment
*)

    type Command =
        | GetType of Item
        | GetValue of Item
        | Ast of DAST_Expr
        | Help
        | Clear
        | Cenv
        | Code of InlineCode
        | Load of string
        | Infos of int
        | Functions
        | Exit
    and InlineCode = Statement of DAST_Statement | Expr of DAST_Expr
    and Item = Expr of DAST_Expr | Function of QualName

    let private getType_expr =
        pipe2
            (spaces >>? (attempt (pstring "t") <|> pstring "type"))
            (spaces1 >>? expression)
            (fun _ expr -> GetType(Item.Expr (exprDesugger expr)))

    let private ast =
        pipe2
            (spaces >>? pstring "ast")
            (spaces1 >>? expression)
            (fun _ expr -> Ast (exprDesugger expr))

    let private getValue =
        pipe2
            (spaces >>? (attempt (pstring "v") <|> pstring "value"))
            (spaces1 >>? qualIdentifier)
            (fun _ func -> GetValue(Item.Function func))

    let private getType_func =
        pipe2
            (spaces >>? (attempt (pstring "t") <|> pstring "type"))
            (spaces1 >>? qualIdentifier)
            (fun _ func -> GetType(Item.Function func))

    let private getType =
        attempt getType_func <|>
                getType_expr

    let private help =
        spaces >>? (attempt (pstring "?") <|> attempt (pstring "h") <|> pstring "help")
        >>% Help

    let private exit =
        spaces >>? (attempt (pstring "q") <|> pstring "quite")
        >>% Exit

    let private clear =
        spaces >>? (attempt (pstring "cls") <|> pstring "clear")
        >>% Clear

    let private cenv =
        spaces >>? pstring "cenv" >>% Cenv

    let private infos =
        spaces >>? (attempt (pstring "i") <|> pstring "infos") >>? pint32
        |>> Infos

    let private functions =
        spaces >>? pstring "functions" >>% Functions

    let private load =
        spaces >>? (attempt (pstring "load") <|> pstring "run") >>? spaces >>? furi
        |>> fun file -> Load(file + ".arl")

    let private inlineCode =
        statement |>> fun stmt -> Code (InlineCode.Statement (statementDesugger stmt))

    let private command =
        attempt (pstring ":" >>?
            choice [attempt getType  ;
                    attempt getValue ;
                    attempt help     ;
                    attempt cenv     ;
                    attempt infos    ;
                    attempt ast      ;
                    attempt load     ; 
                    attempt functions;
                    attempt clear    ; 
                            exit     ]) <|>
        inlineCode

    let rec private execute result cmdStr env =
        match result with
        | Success(cmd, _, _) -> runCommand cmd cmdStr env
        | Failure _ -> Errors.unknownCommand cmdStr

    and private runCommand command cmdStr (env: Env ref) =
        match command with
        | Exit ->
            Infos.bye ()
            System.Threading.Thread.Sleep 800
            Microsoft.FSharp.Core.Operators.exit 0
        | GetType item ->
            Typechecker.resetId ()
            match item with
            | Expr expr ->
                Infos.printInfoType
                    ((cmdStr.Trim().Substring 2).Trim())
                    (Type.toString (snd (tiExpr Map.empty expr)))
            | Function f ->
                let f' = qualNameToString f
                if env.Value.containsFunction f' = false
                then Errors.unexistingFunction f'
                else Infos.printInfoType f' (Type.toString (env.Value.getFunctionType f'))
        | Clear ->
            System.Console.Clear ()
            printfn "%s" (welcome (env.Value.filename))
        | Code code ->
            match code with
            | InlineCode.Statement stmt ->
                env := (typecheck_statement !env stmt)
            | InlineCode.Expr exp -> () // eval
        | Load file ->
            if System.IO.File.Exists file
            then try
                    let fileinfo = System.IO.FileInfo file
                    System.Console.Clear ()
                    runCLI ((typecheck_document (Some fileinfo))
                             (Desugger.desugger (Parser.parse (System.IO.File.ReadAllText file) (Some fileinfo.Name))))
                 with Operators.Failure exn ->
                    printfn "%s" (welcome env.Value.filename)
                    printfn "Arlia> %s" cmdStr
                    Errors.fileLoadingError file exn
            else Errors.unexistingFile file
        | Help -> Infos.help helpText
        | GetValue item ->
            match item with Item.Function id -> printfn "%A" (env.Value.getFunctionValue (qualNameToString id))
        | Ast ast ->
            Printter.Utils.setColor System.ConsoleColor.White
            printfn "%A" ast
            Printter.Utils.resetColor ()
        | Cenv ->
            Printter.Utils.arrow ()
            printfn "%d function deleted from REPL environment" env.Value.functions.Length
            Printter.Utils.arrow ()
            printfn "%d types deleted from REPL environment" env.Value.types.Length
            env := newEnv None
        | Infos index ->
            printfn "Feature incoming!"
        | Functions -> printfn "%s" (System.String.Join(", ", List.map (fun (f: Function) -> f._name) env.Value.functions))

    and public runCLI (env: Env) =
        printfn "%s" (welcome (env.filename))
        let cliEnv = ref env
        while true do
            resetId ()
            printf "%s> "
                (if env.filename = "prelude"
                 then "Arlia"
                 else (env.filename.Remove(env.filename.Length - 4)) + "*")
            let input = System.Console.ReadLine ()
            if input.Trim() = ""
            then System.Console.SetCursorPosition(System.Console.CursorLeft, System.Console.CursorTop - 1)
            else
                let command = runParser (spaces >>? command .>>? spaces .>>? eof) () input
                try execute command input cliEnv
                with | Exceptions.TypeCheckingErrorInsideHandled -> ()
                     | Exceptions.TypeCheckingErrorOutsideHandle msg ->
                        printfn "Typechecking primitive error: %s" msg
                     | Operators.Failure exn -> printfn "Error: %s" exn
                     | _ -> printfn "Oops... Unknown error not managed"


